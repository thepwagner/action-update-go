package handler

import (
	"context"
	"fmt"
	"strings"

	"github.com/dependabot/gomodules-extracted/cmd/go/_internal_/modload"
	"github.com/dependabot/gomodules-extracted/cmd/go/_internal_/semver"
	"github.com/google/go-github/v32/github"
	"github.com/sirupsen/logrus"
	"github.com/thepwagner/action-update-go/cmd"
	"github.com/thepwagner/action-update-go/gomod"
)

// RepositoryVulnerabilityAlert reacts to repository_vulnerability_alerts
// The intent is to produce a PR that upgrades the affected dependency outside the affected range.
func RepositoryVulnerabilityAlert(_ context.Context, _ cmd.Environment, evt interface{}) error {
	// XXX: this is the land of make believe, GitHub does not support security alerts for golang
	rva, ok := evt.(*github.RepositoryVulnerabilityAlertEvent)
	if !ok {
		return fmt.Errorf("invalid event type: %T", evt)
	}

	switch rva.GetAction() {
	case "create":
		return rvaCreate(rva)
	case "dismiss", "resolve":
		// pass
	default:
		logrus.WithField("action", rva.GetAction()).Warn("unexpected action")
	}
	return nil
}

var _ Handler = RepositoryVulnerabilityAlert

func rvaCreate(rva *github.RepositoryVulnerabilityAlertEvent) error {
	// Extract alert from event:
	alert := alertPackage(rva)
	if alert.PackageName == "" || alert.AffectedRange == "" {
		return fmt.Errorf("invalid alert")
	}

	// Confirm the current module version is within the affected range:
	current := gomod.CurrentVersion(alert.PackageName)
	inRange := alert.InRange(current)
	if !inRange {
		return nil
	}

	// Query for the smallest potential upgrade outside of the affected range:
	target, err := modload.Query(alert.PackageName, alert.Invert(), nil)
	if err != nil {
		return fmt.Errorf("querying versions: %w", err)
	}
	logrus.WithField("target_version", target.Version).Info("identified target version")

	// TODO: port dead code to RepoUpdater:
	//if err := gomod.Update(alert.PackageName, target.Version); err != nil {
	//	return err
	//}

	return nil
}

type VulnerabilityAlert struct {
	PackageName   string
	AffectedRange string
	FixedIn       string
}

func (va VulnerabilityAlert) InRange(v string) bool {
	if v == "" {
		return false
	}
	if v[0] != 'v' {
		v = fmt.Sprintf("v%s", v)
	}

	for _, rangeCond := range strings.Split(va.AffectedRange, ",") {
		rangeCond = strings.TrimSpace(rangeCond)
		switch {
		case strings.HasPrefix(rangeCond, "<="):
			cmp := semver.Compare(fmt.Sprintf("v%s", rangeCond[3:]), v)
			if cmp < 0 {
				return false
			}
		case strings.HasPrefix(rangeCond, ">="):
			cmp := semver.Compare(fmt.Sprintf("v%s", rangeCond[3:]), v)
			if cmp > 0 {
				return false
			}
		case strings.HasPrefix(rangeCond, "<"):
			cmp := semver.Compare(fmt.Sprintf("v%s", rangeCond[2:]), v)
			if cmp < 1 {
				return false
			}
		case strings.HasPrefix(rangeCond, ">"):
			cmp := semver.Compare(fmt.Sprintf("v%s", rangeCond[2:]), v)
			if cmp > -1 {
				return false
			}
		}
	}
	return true
}

func (va VulnerabilityAlert) Invert() string {
	var cond []string
	for _, rangeCond := range strings.Split(va.AffectedRange, ",") {
		rangeCond = strings.TrimSpace(rangeCond)
		switch {
		case strings.HasPrefix(rangeCond, "<="):
			cond = append(cond, fmt.Sprintf(">v%s", rangeCond[3:]))
		case strings.HasPrefix(rangeCond, ">="):
			cond = append(cond, fmt.Sprintf("<v%s", rangeCond[3:]))
		case strings.HasPrefix(rangeCond, "<"):
			cond = append(cond, fmt.Sprintf(">=v%s", rangeCond[2:]))
		case strings.HasPrefix(rangeCond, ">"):
			cond = append(cond, fmt.Sprintf("<=v%s", rangeCond[2:]))
		}
	}
	return strings.Join(cond, ", ")
}

func alertPackage(rva *github.RepositoryVulnerabilityAlertEvent) VulnerabilityAlert {
	var a VulnerabilityAlert
	if name := rva.Alert.AffectedPackageName; name != nil {
		a.PackageName = *name
	}
	if affectedRange := rva.Alert.AffectedRange; affectedRange != nil {
		a.AffectedRange = *affectedRange
	}

	logrus.WithFields(logrus.Fields{
		"package_name":   a.PackageName,
		"affected_range": a.AffectedRange,
	}).Info("parsed repository_vulnerability_alert event")
	return a
}
