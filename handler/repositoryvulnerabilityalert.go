package handler

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/dependabot/gomodules-extracted/cmd/go/_internal_/modload"
	"github.com/dependabot/gomodules-extracted/cmd/go/_internal_/semver"
	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/plumbing"
	"github.com/go-git/go-git/v5/plumbing/object"
	"github.com/google/go-github/v32/github"
	"github.com/sirupsen/logrus"
	"github.com/thepwagner/action-update-go/cmd"
	"github.com/thepwagner/action-update-go/gomod"
)

func RepositoryVulnerabilityAlert(_ context.Context, _ cmd.Environment, evt interface{}) error {
	rva, ok := evt.(*github.RepositoryVulnerabilityAlertEvent)
	if !ok {
		return fmt.Errorf("invalid event type: %T", evt)
	}

	switch rva.GetAction() {
	case "create":
		return rvaCreate(rva)
	case "dismiss", "resolve":
		// pass
	default:
		logrus.WithField("action", rva.GetAction()).Warn("unexpected action")
	}
	return nil
}

var _ Handler = RepositoryVulnerabilityAlert

func rvaCreate(rva *github.RepositoryVulnerabilityAlertEvent) error {
	// Extract alert from event:
	alert := alertPackage(rva)
	if alert.PackageName == "" || alert.AffectedRange == "" {
		return fmt.Errorf("invalid alert")
	}

	// Confirm the current module version is within the affected range:
	current := gomod.CurrentVersion(alert.PackageName)
	inRange := alert.InRange(current)
	logrus.WithFields(logrus.Fields{
		"package_name":    alert.PackageName,
		"current_version": current,
		"in_range":        inRange,
	}).Info("loaded current version")
	if !inRange {
		return nil
	}

	// Query for the smallest potential upgrade outside of the affected range:
	target, err := modload.Query(alert.PackageName, alert.Invert(), nil)
	if err != nil {
		return fmt.Errorf("querying versions: %w", err)
	}
	logrus.WithField("target_version", target.Version).Info("identified target version")

	if err := gomod.Update(alert.PackageName, target.Version); err != nil {
		return err
	}

	co := CommitOptions{
		Branch:      fmt.Sprintf("bump/%s/%s", alert.PackageName, target.Version),
		Message:     fmt.Sprintf("upgrade %s to %s", alert.PackageName, target.Version),
		AuthorName:  "test",
		AuthorEmail: "test@test.com",
		Timestamp:   time.Now(),
	}
	return commit(co)
	// TODO: push, open PR?
}

type CommitOptions struct {
	Branch                  string
	Message                 string
	AuthorName, AuthorEmail string
	Timestamp               time.Time
}

func commit(co CommitOptions) error {
	// Open repo:
	repo, err := git.PlainOpen(".")
	if err != nil {
		return fmt.Errorf("opening repo: %w", err)
	}

	// Capture the initial repo state:
	head, err := repo.Head()
	if err != nil {
		return fmt.Errorf("opening repo: %w", err)
	}
	logrus.WithFields(logrus.Fields{
		"branch": head.Name(),
		"hash":   head.Hash(),
	}).Debug("read repo")

	// After, revert to initial state:
	wt, err := repo.Worktree()
	if err != nil {
		return fmt.Errorf("opening worktree: %w", err)
	}
	defer func() {
		err := wt.Checkout(&git.CheckoutOptions{
			Branch: head.Name(),
			Force:  true,
		})
		if err != nil {
			logrus.WithError(err).Warn("resetting git work tree")
		}
	}()

	// Remove any existing branch from previous runs:
	if err := cleanupBranch(repo, co.Branch); err != nil {
		return fmt.Errorf("cleaning up branch: %w", err)
	}

	err = wt.Checkout(&git.CheckoutOptions{
		Create: true,
		Branch: plumbing.NewBranchReferenceName(co.Branch),
		Keep:   true,
	})
	if err != nil {
		return fmt.Errorf("checking out: %w", err)
	}

	// wt.AddGlob() is attractive, but does not respect .gitignore
	// .Status() respects .gitignore so add file by file:
	status, err := wt.Status()
	if err != nil {
		return fmt.Errorf("checking status: %w", err)
	}
	for fn := range status {
		if _, err := wt.Add(fn); err != nil {
			return fmt.Errorf("adding file %q: %w", fn, err)
		}
	}

	commit, err := wt.Commit(co.Message, &git.CommitOptions{
		Author: &object.Signature{
			Name:  co.AuthorName,
			Email: co.AuthorEmail,
			When:  co.Timestamp,
		},
	})
	if err != nil {
		return fmt.Errorf("committing branch")
	}
	logrus.WithFields(logrus.Fields{
		"branch": co.Branch,
		"commit": commit.String(),
	}).Info("committed upgrade")
	return nil
}

func cleanupBranch(repo *git.Repository, branch string) error {
	log := logrus.WithField("branch", branch)

	// if branch is defined in .git/config, delete it:
	if _, err := repo.Branch(branch); err == nil {
		log.Info("removing branch from config")
		if err := repo.DeleteBranch(branch); err != nil {
			return fmt.Errorf("deleting branch: %w", err)
		}
	}

	branchName := plumbing.NewBranchReferenceName(branch)
	if err := repo.Storer.RemoveReference(branchName); err != nil {
		return fmt.Errorf("removing branch ref: %w", err)
	}
	return nil
}

type VulnerabilityAlert struct {
	PackageName   string
	AffectedRange string
	FixedIn       string
}

func (va VulnerabilityAlert) InRange(v string) bool {
	if v == "" {
		return false
	}
	if v[0] != 'v' {
		v = fmt.Sprintf("v%s", v)
	}

	for _, rangeCond := range strings.Split(va.AffectedRange, ",") {
		rangeCond = strings.TrimSpace(rangeCond)
		switch {
		case strings.HasPrefix(rangeCond, "<="):
			cmp := semver.Compare(fmt.Sprintf("v%s", rangeCond[3:]), v)
			if cmp < 0 {
				return false
			}
		case strings.HasPrefix(rangeCond, ">="):
			cmp := semver.Compare(fmt.Sprintf("v%s", rangeCond[3:]), v)
			if cmp > 0 {
				return false
			}
		case strings.HasPrefix(rangeCond, "<"):
			cmp := semver.Compare(fmt.Sprintf("v%s", rangeCond[2:]), v)
			if cmp < 1 {
				return false
			}
		case strings.HasPrefix(rangeCond, ">"):
			cmp := semver.Compare(fmt.Sprintf("v%s", rangeCond[2:]), v)
			if cmp > -1 {
				return false
			}
		}
	}
	return true
}

func (va VulnerabilityAlert) Invert() string {
	var cond []string
	for _, rangeCond := range strings.Split(va.AffectedRange, ",") {
		rangeCond = strings.TrimSpace(rangeCond)
		switch {
		case strings.HasPrefix(rangeCond, "<="):
			cond = append(cond, fmt.Sprintf(">v%s", rangeCond[3:]))
		case strings.HasPrefix(rangeCond, ">="):
			cond = append(cond, fmt.Sprintf("<v%s", rangeCond[3:]))
		case strings.HasPrefix(rangeCond, "<"):
			cond = append(cond, fmt.Sprintf(">=v%s", rangeCond[2:]))
		case strings.HasPrefix(rangeCond, ">"):
			cond = append(cond, fmt.Sprintf("<=v%s", rangeCond[2:]))
		}
	}
	return strings.Join(cond, ", ")
}

func alertPackage(rva *github.RepositoryVulnerabilityAlertEvent) VulnerabilityAlert {
	var a VulnerabilityAlert
	if name := rva.Alert.AffectedPackageName; name != nil {
		a.PackageName = *name
	}
	if affectedRange := rva.Alert.AffectedRange; affectedRange != nil {
		a.AffectedRange = *affectedRange
	}

	logrus.WithFields(logrus.Fields{
		"package_name":   a.PackageName,
		"affected_range": a.AffectedRange,
	}).Info("parsed repository_vulnerability_alert event")
	return a
}
